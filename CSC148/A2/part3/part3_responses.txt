Q1: What does the given quicksort use as a pivot?
The given quicksort uses the median value among the first, the last and the middle element of the given list as a pivot.

Q2: What is this modified quicksort's worst case runtime?
The running time of the quicksort given in this assignment on an already-sorted list is O(nlogn), because if it is a already sorted list, and we take the median value as the pivot, it will partitions the list in half each time, the partition procedure first partitions a list of size n, then n/2, then n/4, and so on, for a total of logn steps, this is the best case. 

Q3: How does this alternate partition compare to the one from lecture?
The alternate partition has one feature that the partition from the lecture doesn’t have is that it also tells you the index of the first element that is equal to the pivot, so it is faster when the list contains a lot of repetitive elements or a lot of elements that are the same as the pivot element. When we use recursion to sort the given list, it got smaller sub-list to take care of, because using the alternate partition, it already put the pivot and all the elements that are the same as the pivot in the correct place. So we only have to sort the elements that are less than and strictly greater than the pivot. On the other hand, the partition from the lecture, it only returns the index of the first element that is greater than or equal to the pivot, it is faster when every element of the given list is unique, or it does not contain elements that are the same as the pivot. If we have several elements that are the same as the pivot, and by using the partition from the lecture, it only gives you the index of the first element that is greater than or equal to the pivot, so when we use recursion to sort the sub-list, we got bigger sub-list that does not only contain elements that are greater than the pivot, but also the elements that are the same as the pivot. So it will be slower in this circumstance.


Q4: How does your new quicksort.py work?
The new quicksort works better than the one using the partition from the lecture, because the partition_alt already sorts out all the elements that are equal to the pivot, and the pivot and all the elements that are equal to the pivot are already in the correct place, so when we use recursion to sort the rest of the list, we got two smaller sub-list to take care of. Unlike the one from the lecture, the partition function only returns the index of the first element that is greater than the pivot, and when we use recursion to sort the rest of the list, we may have many more element that is equal to the pivot that we have to sort again. Also, by using the alternate partition we do not have to eliminate the pivot that is at the end of the list, therefore we don’t need this line of code anymore a[i], a[u] = a[u], a[i], and we also don’t have to swap the pivot to the correct place because when we partition the list using the alternate partition, the pivot and all the elements that are the same as the pivot are already in the correct place, so using the alternate partition take two less steps than using the partition from the lecture. Also, when we use recursion to sort the sub-list, we only need to start from l to the element before the first element that is equal to the pivot, i[0] - 1. And from the first element that is greater to the pivot i[1] to the end index u.