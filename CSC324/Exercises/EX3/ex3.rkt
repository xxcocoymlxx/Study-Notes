#lang racket #| CSC324 Fall 2019: Exercise 3 |#
#|
* Before starting, please review the exercise guidelines at
http://www.cs.toronto.edu/~lczhang/324/assignments.html *
|#
;-------------------------------------------------------------------------------
(provide calculate eval-calc curry-2 fix-first curry-n)


;-------------------------------------------------------------------------------
; * Task 1: Building an environment *
;-------------------------------------------------------------------------------

#|
(calculate expr)
  expr: A datum representing an expression generated by the
        Expanded Binary Arithmetic Expression Grammar in the handout

  Calls the function `eval-calc` with an empty environment
|#


;[note] calculate is using our eval-calc without a given environment!
;It is providing its own bindings in the expr with let*
(define (calculate expr)
  (eval-calc expr (hash)))


#|
(eval-calc expr env)
  expr: A datum representing an expression generated by the
        Expanded Binary Arithmetic Expression Grammar in the handout
  env:  A hash table representing an environment.
        The keys of the hash table are symbols representing identifiers.

  You may assume that if an `expr` is an identifier, then it is present in `env`.

  Relevant documentation:
    https://docs.racket-lang.org/reference/hashtables.html
    (look up `hash-ref`, `hash-set`, and `hash`)

  In Racket, the function `hash-set` takes a hash table, a new key-value pair,
  and returns a *new* hash table with all the elements in the old hash table,
  plus the new key-value pair.

|#
(define/match (eval-calc expr env)
#|
  for the first pattern that we are matching, it's the "let*" option
  if it only has one binding, convert to hash table and directly calculate it
  otherwise, convert the first binding to hash table and reduce your original expression
  to one less binding, and pass them into the function to continue recursion.
|#
  [((list 'let* bindings eqn) _);now "bindings" is the whole list of bindings, and the "_" matches the empty hash table that passed in
   (if (equal? 1 (length bindings))
       ;if only has one binding
       (let* ([new-env (hash-set env (first (first bindings)) (eval-calc (second (first bindings)) env))]);here the last "env" can't be a empty hash
         (eval-calc eqn new-env))
       ;otherwise, reduce the expression and with less binding
    (eval-calc (list 'let* (rest bindings) eqn) (hash-set env (first (first bindings)) (eval-calc (second (first bindings)) env))))]
  
  [((list '+ a b) _) (+ (eval-calc a env) (eval-calc b env))]
  [((list '- a b) _) (- (eval-calc a env) (eval-calc b env))]
  [((list '* a b) _) (* (eval-calc a env) (eval-calc b env))]
  [((list '/ a b) _) (/ (eval-calc a env) (eval-calc b env))]
  [((list 'if (list '= a b) c d) _) (if (equal? (eval-calc a env) (eval-calc b env)) (eval-calc c env) (eval-calc d env))]
  [((list 'if (list '> a b) c d) _) (if (> (eval-calc a env) (eval-calc b env)) (eval-calc c env) (eval-calc d env))]
  [((list 'if (list '< a b) c d) _) (if (< (eval-calc a env) (eval-calc b env)) (eval-calc c env) (eval-calc d env))]
  ;(expr env) here expr is to match single values, either a single number or a symbol
  [(_ _) (if (number? expr) expr (hash-ref env expr))];env is an hash table, expr is the key
  )

(module+ test
  (require rackunit)
  (test-equal? "Environment lookup {a: 3}"
               (eval-calc '(+ a 1) (hash 'a 3))
               4)
  (test-equal? "Let* binding {a: 3}"
               (calculate '(let* ((a 3)) (+ a 1)))
               4)
  (test-equal? "Multiple binding {a: 3, b: 4}"
               (calculate '(let* ((a 3) (b 4)) (+ a b)))
               7)
  (test-equal? "Recursive bindings"
               (calculate '(let* ((a 3) (a (+ a 1))) (* a 2)))
               8)
  (test-equal? "If statements with bindings"
               (calculate '(let* ((a 3) (b 3)) (if (= a b) 1 0)))
               1))
#|

|#
;-------------------------------------------------------------------------------
; * Task 2: Currying *
;-------------------------------------------------------------------------------
; Racket provides a built-in function "curry" that does the first task for you.
; You may NOT use this function in your code---submissions that do so will
; receive a grade of ZERO on the whole exercise!
(define (curry . rest) (error "curry: You may not use this function."))

#|
(curry-2 f)
  f: a *binary* function

  Returns a unary function g that takes an argument x, and returns a
  new unary function h that takes an argument y, such that
  (h y) is equivalent to (f x y).

  Here is a simple Python-style doctest for curry-2.
  We strongly recommend turning it into an executable test case,
  using the "module+ test" approach you've previously seen.

  > (define (add-2-mult x y) (* (+ 2 x) y))
  > (define func (curry-2 add-2-mult))
  > ((func 4) 5)
  30
|#
(define (curry-2 f)
  (lambda (x)
    (lambda (y)
      (f x y))))


(module+ test
  (require rackunit)
  (test-equal? "curry-2/Addition"
               (let ([f (curry-2 (lambda (x y) (+ x y)))])
                 ((f 3) 5))  ; (f 3) is a function call!
               8))



#|
(define fix-first x f)
  x: a positive integer
  f: a function that takes at least 1 argument.

  Returns a new function g that takes one fewer argument than f,
  such that

  (g x2 x3 ... xn) == (f x x2 x3 ... xn)

  Hint: because the arity (number of arguments) of the returned function
  depends on the input f, you can't use something like (lambda (y z) ...)
  to define it. Instead, lookup *rest arguments* and *apply* to complete
  the function.

  Note: you don't need to do any "typechecking"---if the user passes the wrong
  number of arguments to the returned function, calling f should raise an error.


  【rest arguments】
  (lambda rest-id body ...+)
  That is, a lambda expression can have a single rest-id that is not surrounded
  by parentheses. The resulting function accepts any number of arguments, and
  the arguments are put into a list bound to rest-id.
|#
(define (fix-first x f)
  (lambda rest
      (apply f (cons x rest))))

(module+ test
  (test-equal? "fix-first/ternary"
              (let ([f2 (fix-first 3
                                   (lambda (x y z) (+ x (* y z))))])
                (f2 5 8))
              ; We've deliberately left the body unexpanded to show what's going on.
              (+ 3 (* 5 8))))


#|
(curry-n n f)
  n: a positive integer
  f: a function that takes n arguments

  A generalization of curry-2, except now f takes n arguments;
  curry-n returns a function g that is the curried version of f.

  Notes and hints:
    1. It is possible to define curry-2 in terms of curry-n
       (but doing curry-2 yourself first is easier).
    2. Review the handout's examples of currying to determine the correct
       *recursive structure* for this function.
    3. If g = (curry-n n f), how is (g x) related to (fix-first x f)?
|#
(define/match (curry-n n f)
  [(0 f) f]
  [(1 f) (lambda (x) (f x))]
  [(n f) (lambda (x)
           (curry-n (- n 1) (fix-first x f)))])
  
(module+ test
  ; NOTE: don't uncomment the test below until you've written
  ; your own test for a good *base case* for curry-n!
  ; (Until you're confident in your base case, you likely won't
  ; have much luck with a correct recursive case.)
  (test-equal? "curry-n/BaseCase"
               (let ([g (curry-n 2
                                 (lambda (x y) (+ x y)))])
                 ((g 3) 5))
               8)

  (test-equal? "curry-n/ternary"
               (let ([f3 (curry-n 3
                                  (lambda (x y z) (+ x (* y z))))])
                 (((f3 3) 5) 8))
               (+ 3 (* 5 8))))
