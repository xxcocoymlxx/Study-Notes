#lang racket #| CSC324 Fall 2018: Exercise 4 |#
#|
* Before starting, please review the exercise guidelines at
http://www.cs.toronto.edu/~lczhang/324/assignments.html *
|#
;-------------------------------------------------------------------------------
(provide calculate eval-calc analyze-strictness)

;-------------------------------------------------------------------------------
; * Task 1: Eager Evaluation *
;-------------------------------------------------------------------------------

#|
(calculate expr)
  expr: A datum representing an expression generated by the
        grammar in the Exericse 4 handout
|#
(define (calculate expr)
  (eval-calc expr (hash)))

#|
(eval-calc expr env)
  expr: A datum representing an expression generated by the
        grammar in the Exercise 4 handout
  env:  A hash table representing an environment.
        The keys of the hash table are symbols representing identifiers.

  You may assume that if an `expr` is an identifier, then it is present in `env`.

|#
(define/match (eval-calc expr env)
  [((list 'let* bindings eqn) _)
   (if (equal? 1 (length bindings))
       (let* ([new-env (hash-set env (first (first bindings)) (eval-calc (second (first bindings)) env))]) (eval-calc eqn new-env))
    (eval-calc (list 'let* (rest bindings) eqn) (hash-set env (first (first bindings)) (eval-calc (second (first bindings)) env))))]
  [((list '+ a b) _) (+ (eval-calc a env) (eval-calc b env))]
  [((list '- a b) _) (- (eval-calc a env) (eval-calc b env))]
  [((list '* a b) _) (* (eval-calc a env) (eval-calc b env))]
  [((list '/ a b) _) (/ (eval-calc a env) (eval-calc b env))]
  [((list 'if (list '= a b) c d) _) (if (equal? (eval-calc a env) (eval-calc b env)) (eval-calc c env) (eval-calc d env))]
  [((list 'if (list '> a b) c d) _) (if (> (eval-calc a env) (eval-calc b env)) (eval-calc c env) (eval-calc d env))]
  [((list 'if (list '< a b) c d) _) (if (< (eval-calc a env) (eval-calc b env)) (eval-calc c env) (eval-calc d env))]
  ;create closure only, no arguments yet, empty hash table
  [((list 'lambda IDs expr) _) (list 'closure (list 'lambda IDs expr) env)]

  [(_ _) (cond
           [(number? expr) expr]
           [(symbol? expr) (hash-ref env expr)]
           [(null? expr) 0]
           [(symbol? (first expr))(eval-calc (append (list (eval-calc (first expr) env)) (rest expr)) env)]
           [(list? (first expr))
            (if (equal? 'closure (first (first expr)))
                ;if it's a closure
                (if (equal? 1 (length expr));if no more argument
                    (eval-calc (third (second (first expr))) (third (first expr)));evaluate it directly with its own env
                    ;if there are more argument
                     (let* ([new-env 
                        (hash-set (third (first expr))
                                       (list-ref (second (second (first expr))) (- (length (second (second (first expr)))) (length (rest expr))))
                                       (eval-calc (first (rest expr)) env))])
                       (eval-calc (append (list (list 'closure (second (first expr)) new-env)) (rest (rest expr))) env)))
                 ;if its not a closure
                  (let ([first-lst (eval-calc (first expr) env)];a closure ready to use
                  [rest-lst (rest expr)]);list of arguments
                 (eval-calc (append (list first-lst) rest-lst) env)));convert lambda to a closure and continue recursion
  ]
  )])


(module+ test
  (require rackunit)
  ; You should write more tests to make sure that your
  ; interpreter uses lexical scoping

  (test-equal? "Function definition"
               (calculate '((lambda (a) (+ a 1)) 4))
               5)

  (test-equal? "Functions with multiple arguments"
               (calculate '((lambda (a b) (+ b 1)) 4 14))
               15)

  (test-equal? "Functions with multiple arguments"
               (calculate '((lambda (a b) (+ a b)) (let* ((b 3)) (+ b 2)) 4))
               9)

  (test-equal? "Functions with multiple arguments"
               (calculate '(let* ((a 3) (b 3)) (if (= a b) (let* ((d (+ a 1))) (+ d 2)) 0)))
               6)

  (test-equal? "Functions with multiple arguments"
               (calculate '((lambda (a b) (+ ((lambda (c) (* 2 c)) 3) 1)) 5 6))
               7)
  
  (test-equal? "Functions with multiple arguments"
               (calculate '(let* ((f (lambda (x) (+ x 1)))) (f 5)))
               6)
  
  (test-equal? "Functions with multiple arguments"
               (calculate '(let* ((n 10) (f (lambda (x) n)) (g (lambda (n) (f 3)))) (g 100)))
               10)

    (test-equal? "Functions with multiple arguments"
               (calculate '(let* ((n 10) (f (lambda (x) (* x n)))) (f 5)))
               50)

  (test-equal? "Functions with multiple arguments"
               (calculate '(let* ((f (lambda (x) (+ x 1)))) (f 5)))
               6)

  (test-equal? "Functions with multiple arguments"
               (calculate '(let* ((f (lambda (x) (+ x 1))) (g (lambda () f))) ((g) 5)))
               6)
  (test-equal? "Functions with multiple arguments"
               (calculate '((lambda (x) (let* ((addx (lambda (a) (+ a x)))) ((lambda (x y) (addx y)) 10 20))) 5))
               25)
  
  (test-equal? "Functions with multiple arguments"
               (calculate '(let* ((x 5) (addx (lambda (a) (+ a x)))) ((lambda (x y) (addx y)) 10 20)))
               25)
  
  (test-equal? "Functions with multiple arguments"
               (calculate '(let* ((f (lambda (a x) (lambda (a2) (x a2))))) ((f 9 (lambda (x2) x2) ) 1)))
               1)
)
;-------------------------------------------------------------------------------
; * Task 1: Strictness analysis *
;-------------------------------------------------------------------------------
#|
(analyze-strictness func-defs)
  func-defs:
      A datum representing a program as specified by the grammar on the handout.
      (In this case, it's a list of function definitions.)

  Returns a *strictness map*, which is a hash table mapping function names (as symbols)
  to a list of indexes of the strict parameters of that function.
  Each list should be in increasing order.

  Remember, you may assume that the program has no syntactic or semantic errors
  (so you don't even need to watch out for things like duplicate names).

  Hash table reference: https://docs.racket-lang.org/reference/hashtables.html.

  Implementation hints:
    1. Same as Exercise 3, the main work can be done by processing the list of
       function definitions in a call to foldl.
    2. Working with list indexes is a bit more annoying in pure functional land.
       Use the list function `indexes-where`, which is similar to `filter` except
       it returns indexes rather than elements.

my foldl(lambda (hash) (function identifiers) (their corresponding arguments))

((define (f x) x))
|#
(define (analyze-strictness func-defs)
  (let (
  [func-IDs (map (lambda (lst) (first (second lst))) func-defs)]
  [func-args (map (lambda (lst) (rest (second lst))) func-defs)]
  [func-expr (map (lambda (lst) (third lst)) func-defs)])
  (foldl (lambda (func-IDs func-args func-expr s-map) (hash-set s-map func-IDs (indexes-where func-args (lambda (id) (strict-in? s-map id func-expr)))))
         (hash) func-IDs func-args func-expr))
  )

#|
(strict-in? id expr)
  id: An identifier
  expr: A quoted expression in the grammar specified by the assignment handout.

  Returns whether id is strict in the given expression.
  Uses the given strictness map to determine strictness in function calls.

  NOTE: this function isn't being tested explicitly, so you may freely change it or
  ignore it for this exercise.

  Implementation hint:
    Remember that `and` and `or` aren't function identifiers: you can't pass them to
    Higher Ooder Functions like `map` or `apply`. But you can use functions like `andmap` and `ormap`
    to achieve similar effects.

we need the hash table for the last case, we need the hash table to check if the index we currently have
corresponds to the position
(define (f a b) a), we have {f:0}
(f x 1), we know that the parameter at position 0 is strict

we have an id, and a hash map with variable's indexes 
|#
(define (strict-in? s-map id expr)
  (cond
    [(number? expr) #f]
    [(symbol? expr) (equal? id expr)]
    [(equal? 'if (first expr)) (if (equal? #t (strict-in? s-map id (second expr))) #t (andmap (lambda (expr) (strict-in? s-map id expr)) (rest (rest expr))))]
    [(equal? '+ (first expr)) (ormap (lambda (expr) (strict-in? s-map id expr)) (rest expr))]
    [(symbol? (first expr)) (if (equal? id (first expr)) #t (list? (member (index-of (rest expr) id) (hash-ref s-map (first expr)))))]))



(module+ test
  (require rackunit)

  (test-equal? "Identity function"
               (analyze-strictness '((define (f x) x)))
               (hash
                'f (list 0)))

  (test-equal? "One function, with if (1)"
               (analyze-strictness '((define (f x) (if x 3 5))))
               (hash
                'f (list 0)))

  (test-equal? "One function, with +"
               (analyze-strictness '((define (f x y z) (+ x y))))
               (hash
                'f (list 0 1)))

  (test-equal? "One function, with +"
               (analyze-strictness '((define (f1 a b) a)))
               (hash
                'f1 (list 0)))
  (test-equal? "One function, with +"
               (analyze-strictness '((define (f2 a b c) (+ b c))))
               (hash
                'f2 (list 1 2)))
  (test-equal? "One function, with +"
               (analyze-strictness '((define (f3 a b c d) 10)))
               (hash
                'f3 (list)))
  (test-equal? "One function, with +"
               (analyze-strictness '((define (f x y z) x) (define (g x y z) (f 1 x))))
               '#hash((f . (0)) (g . ())))
  (test-equal? "One function, with +"
               (analyze-strictness '((define (f x y z) (if x y z)) (define (h a b) (+ (f a b b) 2))))
               '#hash((f . (0)) (h . (0))))
  (test-equal? "One function, with +"
               (analyze-strictness '((define (f x y) (if x y 2)) (define (g a) (f a 0))))
               '#hash((f . (0)) (g . (0))))

  )
